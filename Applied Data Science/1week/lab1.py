from pandas import DataFrame
import pandas as pd

with open('2_taxi_nyc.csv') as file:
    data = pd.read_csv(file, delimiter=',')

df = DataFrame(data)
print(df.head(3))

print()
print(1)

# 1. Замените пробел в названиях на знак нижнего подчеркивания.
df.columns = df.columns.str.replace(' ', '_')
print(df.head(3))

print()
print(2)
# Вас попросили узнать, сколько записей (строк) в датафрейме относятся к району Манхэттен (Manhattan). Получить ответ на данный вопрос можно было бы, например, с помощью следующей команды:
# taxi.query("borough == 'Manhattan'").shape[0]
# А если мы хотим посмотреть, сколько раз встречается каждый из районов? Неужели придется использовать подобную конструкцию для каждого уровня переменной? Здесь на помощь приходит метод value_counts()
# Сколько раз в данных встречается район Бруклин (Brooklyn)?
print(df['borough'].value_counts()['Brooklyn'])

print()
print(3)

# выяснить, из какого района было совершено наибольшее количество поездок за весь период. Для начала, посчитайте общее количество поездок (pickups), без группировки.
print(df['pickups'].sum())

print()
print(4)

# А теперь сгруппируйте данные по району (borough) и укажите, из какого пункта было совершено больше всего поездок.
print(df.groupby('borough')['pickups'].sum().sort_values(ascending=False))

print()
print(5)

#Еще несколько полезных методов в pandas! Возможно, в предыдущем степе вы просто посмотрели на данные или отсортировали значения. Ускорить данный процесс в дальнейшем помогут методы idxmin() и idxmax(), которые возвращают индекс минимального или максимального значения.
# idxmin – индекс минимального значения
# idxmax – индекс максимального значения
# Сохраните название района с наименьшим числом поездок в переменную min_pickups, применив подходящий метод.
min_pickups = df.groupby('borough')['pickups'].sum().idxmin()
print(min_pickups)

print()
print(6)

# Продолжим изучение данных и посмотрим на число поездок в выходные дни. Сгруппируйте данные по двум признакам: району города и является ли день выходным (колонки borough и hday). Сравните среднее число поездок, и выберите районы, из которых по праздникам в среднем поступает больше заказов, чем в обычные дни.
print(df.groupby(['borough', 'hday'])['pickups'].mean().sort_values(ascending=False))

print()
print(7)

# Для каждого района посчитайте число поездок по месяцам. Отсортируйте полученные значения по убыванию и сохраните результирующий датафрейм в pickups_by_mon_bor.
# Обратите внимание, что итоговый датасет должен состоять из 3-х колонок - pickup_month, borough, pickups.
# Данные сохранены в переменную taxi.
pickups_by_mon_bor = df.groupby(['pickup_month', 'borough'])['pickups'].sum().sort_values(ascending=False)
taxi = pickups_by_mon_bor.reset_index()
print(taxi)

print()
print(8)

# Теперь задача посложнее! Попрактикуемся в написании собственных функций и их применении к датафрейму. Поскольку данные о поездках в Нью-Йорке, температура представлена в градусах Фаренгейта.
# Напишите функцию temp_to_celcius, которая получает на вход колонку с температурой в °F, и возвращает значения, переведенные в градусы Цельсия.
def temp_to_celcius(temp_f):
    temp_c = (temp_f - 32) * 5 / 9
    return temp_c


df['temp_c'] = temp_to_celcius(df['temp'])

print(df.head(10))

